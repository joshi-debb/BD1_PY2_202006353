-- Descripcion: Script para el proyecto 2

-- CREAR BASE DE DATOS

CREATE SCHEMA IF NOT EXISTS BD1PY2;

-- SELECCIONAR BASE DE DATOS

USE BD1PY2;

-- CREAR TABLA CARRERA

CREATE TABLE IF NOT EXISTS BD1PY2.CARRERA (
    id_carrera INT NOT NULL AUTO_INCREMENT,
    nombre VARCHAR(30) NOT NULL,
    
    PRIMARY KEY (id_carrera)

);

-- CREAR TABLA ESTUDIANTE

CREATE TABLE IF NOT EXISTS BD1PY2.ESTUDIANTE (
    carnet VARCHAR(10) NOT NULL,
    dpi VARCHAR(20) NOT NULL,
    nombre VARCHAR(30) NOT NULL,
    apellido VARCHAR(30) NOT NULL,
    fecha_nac DATE NOT NULL,
    correo VARCHAR(100) NOT NULL,
    telefono VARCHAR(8) NOT NULL,
    direccion VARCHAR(100) NOT NULL,
    creditos INT NOT NULL,
    fecha DATE NOT NULL,
    id_carrera INT NOT NULL,
    
    PRIMARY KEY (carnet),
    FOREIGN KEY (id_carrera) REFERENCES BD1PY2.CARRERA(id_carrera)

);

-- CREAR TABLA DOCENTE

CREATE TABLE IF NOT EXISTS BD1PY2.DOCENTE (
    siif VARCHAR(10) NOT NULL,
    dpi VARCHAR(20) NOT NULL,
    nombre VARCHAR(30) NOT NULL,
    apellido VARCHAR(30) NOT NULL,
    fecha_nac DATE NOT NULL,
    correo VARCHAR(100) NOT NULL,
    telefono VARCHAR(8) NOT NULL,
    direccion VARCHAR(100) NOT NULL,
    fecha DATE NOT NULL,
    
    PRIMARY KEY (siif)

);

-- CREAR TABLA CURSO

CREATE TABLE IF NOT EXISTS BD1PY2.CURSO (
    cod_curso VARCHAR(10) NOT NULL,
    nombre VARCHAR(100) NOT NULL,
    creditos_nec INT NOT NULL,
    creditos_otg INT NOT NULL,
    obligatorio BOOLEAN NOT NULL,
    id_carrera INT NOT NULL,
    
    PRIMARY KEY (cod_curso),
    FOREIGN KEY (id_carrera) REFERENCES BD1PY2.CARRERA(id_carrera)

);

-- CREAR TABLA CURSO_HABILITADO

CREATE TABLE IF NOT EXISTS BD1PY2.CURSO_HABILITADO (
    id_ch INT NOT NULL AUTO_INCREMENT,
    cupo_max INT NOT NULL,
    seccion VARCHAR(2) NOT NULL,
    anio VARCHAR(4) NOT NULL,
    cod_curso VARCHAR(10) NOT NULL,
    siif VARCHAR(10) NOT NULL,
    ciclo VARCHAR(10) NOT NULL,
    
    PRIMARY KEY (id_ch),
    FOREIGN KEY (cod_curso) REFERENCES BD1PY2.CURSO(cod_curso),
    FOREIGN KEY (siif) REFERENCES BD1PY2.DOCENTE(siif)

);


-- CREAR TABLA HORARIO

CREATE TABLE IF NOT EXISTS BD1PY2.HORARIO (
    id_horaio INT NOT NULL AUTO_INCREMENT,
    dia VARCHAR(10) NOT NULL,
    hora VARCHAR(20) NOT NULL,
    id_ch INT NOT NULL,
    
    PRIMARY KEY (id_horaio),
    FOREIGN KEY (id_ch) REFERENCES BD1PY2.CURSO_HABILITADO(id_ch)

);

-- CREAR TABLA ASIGNACION

CREATE TABLE IF NOT EXISTS BD1PY2.ASIGNACION (
    id_asignacion INT NOT NULL AUTO_INCREMENT,
    carnet VARCHAR(10) NOT NULL,
    id_ch INT NOT NULL,

    PRIMARY KEY (id_asignacion),
    FOREIGN KEY (carnet) REFERENCES BD1PY2.ESTUDIANTE(carnet),
    FOREIGN KEY (id_ch) REFERENCES BD1PY2.CURSO_HABILITADO(id_ch)

);

-- CREAR TABLA DESASIGNACION

CREATE TABLE IF NOT EXISTS BD1PY2.DESASIGNACION (
    id_desasignacion INT NOT NULL AUTO_INCREMENT,
    carnet VARCHAR(10) NOT NULL,
    id_ch INT NOT NULL,

    PRIMARY KEY (id_desasignacion),
    FOREIGN KEY (carnet) REFERENCES BD1PY2.ESTUDIANTE(carnet),
    FOREIGN KEY (id_ch) REFERENCES BD1PY2.CURSO_HABILITADO(id_ch)

);

-- CREAR TABLA ASIGNADOS

CREATE TABLE IF NOT EXISTS BD1PY2.ASIGNADOS (
    id_asignados INT NOT NULL AUTO_INCREMENT,
    cantidad INT NOT NULL,
    id_ch INT NOT NULL,

    PRIMARY KEY (id_asignados),
    FOREIGN KEY (id_ch) REFERENCES BD1PY2.CURSO_HABILITADO(id_ch)

);

-- CREAR TABLA NOTA

CREATE TABLE IF NOT EXISTS BD1PY2.NOTA (
    id_nota INT NOT NULL AUTO_INCREMENT,
    nota INT NOT NULL,
    carnet VARCHAR(10) NOT NULL,
    id_ch INT NOT NULL,

    PRIMARY KEY (id_nota),
    FOREIGN KEY (carnet) REFERENCES BD1PY2.ESTUDIANTE(carnet),
    FOREIGN KEY (id_ch) REFERENCES BD1PY2.CURSO_HABILITADO(id_ch)

);

-- CREAR TABLA ACTA

CREATE TABLE IF NOT EXISTS BD1PY2.ACTA (
    id_acta INT NOT NULL AUTO_INCREMENT,
    fecha DATE NOT NULL,
    hora TIME NOT NULL,
    id_ch INT NOT NULL,

    PRIMARY KEY (id_acta),
    FOREIGN KEY (id_ch) REFERENCES BD1PY2.CURSO_HABILITADO(id_ch)

);

-- CREAR TABLA HISTORIAL

CREATE TABLE IF NOT EXISTS BD1PY2.HISTORIAL (
    id_historial INT NOT NULL AUTO_INCREMENT,
    fecha DATE NOT NULL,
    descripcion VARCHAR(200) NOT NULL,
    tipo VARCHAR(20) NOT NULL,

    PRIMARY KEY (id_historial)

);

-- Triggers

-- trigger para guardar historial de trasacciones, carrera

DROP TRIGGER IF EXISTS insert_carrera;

DELIMITER $$
CREATE TRIGGER insert_carrera AFTER INSERT ON BD1PY2.CARRERA
FOR EACH ROW
BEGIN
    SELECT NOW() INTO @fecha;
    INSERT INTO BD1PY2.HISTORIAL(fecha, descripcion, tipo) VALUES(@fecha, 'Se ha creado una carrera.', 'INSERT');
END$$
DELIMITER ;

DROP TRIGGER IF EXISTS update_carrera;

DELIMITER $$
CREATE TRIGGER update_carrera AFTER UPDATE ON BD1PY2.CARRERA
FOR EACH ROW
BEGIN
    SELECT NOW() INTO @fecha;
    INSERT INTO BD1PY2.HISTORIAL(fecha, descripcion, tipo) VALUES(@fecha, 'Se ha actualizado una carrera.', 'UPDATE');
END$$
DELIMITER ;

DROP TRIGGER IF EXISTS delete_carrera;

DELIMITER $$
CREATE TRIGGER delete_carrera AFTER DELETE ON BD1PY2.CARRERA
FOR EACH ROW
BEGIN
    SELECT NOW() INTO @fecha;
    INSERT INTO BD1PY2.HISTORIAL(fecha, descripcion, tipo) VALUES(@fecha, 'Se ha eliminado una carrera.', 'DELETE');
END$$
DELIMITER ;

-- trigger para guardar historial de trasacciones, estudiante

DROP TRIGGER IF EXISTS insert_estudiante;

DELIMITER $$
CREATE TRIGGER insert_estudiante AFTER INSERT ON BD1PY2.ESTUDIANTE
FOR EACH ROW
BEGIN
    SELECT NOW() INTO @fecha;
    INSERT INTO BD1PY2.HISTORIAL(fecha, descripcion, tipo) VALUES(@fecha, 'Se ha creado un estudiante.', 'INSERT');
END$$
DELIMITER ;

DROP TRIGGER IF EXISTS update_estudiante;

DELIMITER $$
CREATE TRIGGER update_estudiante AFTER UPDATE ON BD1PY2.ESTUDIANTE
FOR EACH ROW
BEGIN
    SELECT NOW() INTO @fecha;
    INSERT INTO BD1PY2.HISTORIAL(fecha, descripcion, tipo) VALUES(@fecha, 'Se ha actualizado un estudiante.', 'UPDATE');
END$$
DELIMITER ;

DROP TRIGGER IF EXISTS delete_estudiante;

DELIMITER $$
CREATE TRIGGER delete_estudiante AFTER DELETE ON BD1PY2.ESTUDIANTE
FOR EACH ROW
BEGIN
    SELECT NOW() INTO @fecha;
    INSERT INTO BD1PY2.HISTORIAL(fecha, descripcion, tipo) VALUES(@fecha, 'Se ha eliminado un estudiante.', 'DELETE');
END$$
DELIMITER ;

-- trigger para guardar historial de trasacciones, docente

DROP TRIGGER IF EXISTS insert_docente;

DELIMITER $$
CREATE TRIGGER insert_docente AFTER INSERT ON BD1PY2.DOCENTE
FOR EACH ROW
BEGIN
    SELECT NOW() INTO @fecha;
    INSERT INTO BD1PY2.HISTORIAL(fecha, descripcion, tipo) VALUES(@fecha, 'Se ha creado un docente.', 'INSERT');
END$$
DELIMITER ;

DROP TRIGGER IF EXISTS update_docente;

DELIMITER $$
CREATE TRIGGER update_docente AFTER UPDATE ON BD1PY2.DOCENTE
FOR EACH ROW
BEGIN
    SELECT NOW() INTO @fecha;
    INSERT INTO BD1PY2.HISTORIAL(fecha, descripcion, tipo) VALUES(@fecha, 'Se ha actualizado un docente.', 'UPDATE');
END$$
DELIMITER ;

DROP TRIGGER IF EXISTS delete_docente;

DELIMITER $$
CREATE TRIGGER delete_docente AFTER DELETE ON BD1PY2.DOCENTE
FOR EACH ROW
BEGIN
    SELECT NOW() INTO @fecha;
    INSERT INTO BD1PY2.HISTORIAL(fecha, descripcion, tipo) VALUES(@fecha, 'Se ha eliminado un docente.', 'DELETE');
END$$
DELIMITER ;

-- trigger para guardar historial de trasacciones, curso

DROP TRIGGER IF EXISTS insert_curso;

DELIMITER $$
CREATE TRIGGER insert_curso AFTER INSERT ON BD1PY2.CURSO
FOR EACH ROW
BEGIN
    SELECT NOW() INTO @fecha;
    INSERT INTO BD1PY2.HISTORIAL(fecha, descripcion, tipo) VALUES(@fecha, 'Se ha creado un curso.', 'INSERT');
END$$
DELIMITER ;

DROP TRIGGER IF EXISTS update_curso;

DELIMITER $$
CREATE TRIGGER update_curso AFTER UPDATE ON BD1PY2.CURSO
FOR EACH ROW
BEGIN
    SELECT NOW() INTO @fecha;
    INSERT INTO BD1PY2.HISTORIAL(fecha, descripcion, tipo) VALUES(@fecha, 'Se ha actualizado un curso.', 'UPDATE');
END$$
DELIMITER ;

DROP TRIGGER IF EXISTS delete_curso;

DELIMITER $$
CREATE TRIGGER delete_curso AFTER DELETE ON BD1PY2.CURSO
FOR EACH ROW
BEGIN
    SELECT NOW() INTO @fecha;
    INSERT INTO BD1PY2.HISTORIAL(fecha, descripcion, tipo) VALUES(@fecha, 'Se ha eliminado un curso.', 'DELETE');
END$$
DELIMITER ;

-- trigger para guardar historial de trasacciones, curso_habilitado

DROP TRIGGER IF EXISTS insert_curso_habilitado;

DELIMITER $$
CREATE TRIGGER insert_curso_habilitado AFTER INSERT ON BD1PY2.CURSO_HABILITADO
FOR EACH ROW
BEGIN
    SELECT NOW() INTO @fecha;
    INSERT INTO BD1PY2.HISTORIAL(fecha, descripcion, tipo) VALUES(@fecha, CONCAT('Se ha creado un curso habilitado con id: ', NEW.id_ch), 'INSERT');
END$$
DELIMITER ;

DROP TRIGGER IF EXISTS update_curso_habilitado;

DELIMITER $$
CREATE TRIGGER update_curso_habilitado AFTER UPDATE ON BD1PY2.CURSO_HABILITADO
FOR EACH ROW
BEGIN
    SELECT NOW() INTO @fecha;
    INSERT INTO BD1PY2.HISTORIAL(fecha, descripcion, tipo) VALUES(@fecha, CONCAT('Se ha actualizado un curso habilitado con id: ', NEW.id_ch), 'UPDATE');
END$$
DELIMITER ;

DROP TRIGGER IF EXISTS delete_curso_habilitado;

DELIMITER $$
CREATE TRIGGER delete_curso_habilitado AFTER DELETE ON BD1PY2.CURSO_HABILITADO
FOR EACH ROW
BEGIN
    SELECT NOW() INTO @fecha;
    INSERT INTO BD1PY2.HISTORIAL(fecha, descripcion, tipo) VALUES(@fecha, CONCAT('Se ha eliminado un curso habilitado con id: ', OLD.id_ch), 'DELETE');
END$$
DELIMITER ;

-- trigger para guardar historial de trasacciones, horario

DROP TRIGGER IF EXISTS insert_horario;

DELIMITER $$
CREATE TRIGGER insert_horario AFTER INSERT ON BD1PY2.HORARIO
FOR EACH ROW
BEGIN
    SELECT NOW() INTO @fecha;
    INSERT INTO BD1PY2.HISTORIAL(fecha, descripcion, tipo) VALUES(@fecha, CONCAT('Se ha creado un horario con id: ', NEW.id_horaio), 'INSERT');
END$$
DELIMITER ;

DROP TRIGGER IF EXISTS update_horario;

DELIMITER $$
CREATE TRIGGER update_horario AFTER UPDATE ON BD1PY2.HORARIO
FOR EACH ROW
BEGIN
    SELECT NOW() INTO @fecha;
    INSERT INTO BD1PY2.HISTORIAL(fecha, descripcion, tipo) VALUES(@fecha, CONCAT('Se ha actualizado un horario con id: ', NEW.id_horaio), 'UPDATE');
END$$
DELIMITER ;

DROP TRIGGER IF EXISTS delete_horario;

DELIMITER $$
CREATE TRIGGER delete_horario AFTER DELETE ON BD1PY2.HORARIO
FOR EACH ROW
BEGIN
    SELECT NOW() INTO @fecha;
    INSERT INTO BD1PY2.HISTORIAL(fecha, descripcion, tipo) VALUES(@fecha, CONCAT('Se ha eliminado un horario con id: ', OLD.id_horaio), 'DELETE');
END$$
DELIMITER ;

-- trigger para guardar historial de trasacciones, asignacion

DROP TRIGGER IF EXISTS insert_asignacion;

DELIMITER $$
CREATE TRIGGER insert_asignacion AFTER INSERT ON BD1PY2.ASIGNACION
FOR EACH ROW
BEGIN
    SELECT NOW() INTO @fecha;
    INSERT INTO BD1PY2.HISTORIAL(fecha, descripcion, tipo) VALUES(@fecha, CONCAT('Se ha asignado un estudiante.'), 'INSERT');
END$$
DELIMITER ;

DROP TRIGGER IF EXISTS update_asignacion;

DELIMITER $$
CREATE TRIGGER update_asignacion AFTER UPDATE ON BD1PY2.ASIGNACION
FOR EACH ROW
BEGIN
    SELECT NOW() INTO @fecha;
    INSERT INTO BD1PY2.HISTORIAL(fecha, descripcion, tipo) VALUES(@fecha, CONCAT('Se actualizo la asignacion de un estudiante.'), 'UPDATE');
END$$
DELIMITER ;

DROP TRIGGER IF EXISTS delete_asignacion;

DELIMITER $$
CREATE TRIGGER delete_asignacion AFTER DELETE ON BD1PY2.ASIGNACION
FOR EACH ROW
BEGIN
    SELECT NOW() INTO @fecha;
    INSERT INTO BD1PY2.HISTORIAL(fecha, descripcion, tipo) VALUES(@fecha, CONCAT('Se desasigno un estudiante.'), 'DELETE');
END$$
DELIMITER ;

-- trigger para guardar historial de trasacciones, desasignacion

DROP TRIGGER IF EXISTS insert_desasignacion;

DELIMITER $$
CREATE TRIGGER insert_desasignacion AFTER INSERT ON BD1PY2.DESASIGNACION
FOR EACH ROW
BEGIN
    SELECT NOW() INTO @fecha;
    INSERT INTO BD1PY2.HISTORIAL(fecha, descripcion, tipo) VALUES(@fecha, CONCAT('Se desasigno un estudiante.'), 'INSERT');
END$$
DELIMITER ;

DROP TRIGGER IF EXISTS update_desasignacion;

DELIMITER $$
CREATE TRIGGER update_desasignacion AFTER UPDATE ON BD1PY2.DESASIGNACION
FOR EACH ROW
BEGIN
    SELECT NOW() INTO @fecha;
    INSERT INTO BD1PY2.HISTORIAL(fecha, descripcion, tipo) VALUES(@fecha, 'Se actualizo la desasignacion de un estudiante.', 'UPDATE');
END$$
DELIMITER ;

DROP TRIGGER IF EXISTS delete_desasignacion;

DELIMITER $$
CREATE TRIGGER delete_desasignacion AFTER DELETE ON BD1PY2.DESASIGNACION
FOR EACH ROW
BEGIN
    SELECT NOW() INTO @fecha;
    INSERT INTO BD1PY2.HISTORIAL(fecha, descripcion, tipo) VALUES(@fecha,'Se desasigno un estudiante.', 'DELETE');
END$$
DELIMITER ;

-- trigger para guardar historial de trasacciones, asignados

DROP TRIGGER IF EXISTS insert_asignados;

DELIMITER $$
CREATE TRIGGER insert_asignados AFTER INSERT ON BD1PY2.ASIGNADOS
FOR EACH ROW
BEGIN
    SELECT NOW() INTO @fecha;
    INSERT INTO BD1PY2.HISTORIAL(fecha, descripcion, tipo) VALUES(@fecha,'Se asignaron cupos a un curso.', 'INSERT');
END$$
DELIMITER ;

DROP TRIGGER IF EXISTS update_asignados;

DELIMITER $$
CREATE TRIGGER update_asignados AFTER UPDATE ON BD1PY2.ASIGNADOS
FOR EACH ROW
BEGIN
    SELECT NOW() INTO @fecha;
    INSERT INTO BD1PY2.HISTORIAL(fecha, descripcion, tipo) VALUES(@fecha,'Se actualizo la asignacion de cupos a un curso.', 'UPDATE');
END$$
DELIMITER ;

DROP TRIGGER IF EXISTS delete_asignados;

DELIMITER $$
CREATE TRIGGER delete_asignados AFTER DELETE ON BD1PY2.ASIGNADOS
FOR EACH ROW
BEGIN
    SELECT NOW() INTO @fecha;
    INSERT INTO BD1PY2.HISTORIAL(fecha, descripcion, tipo) VALUES(@fecha,'Se desasignaron cupos a un curso.', 'DELETE');
END$$
DELIMITER ;

-- trigger para guardar historial de trasacciones, nota

DROP TRIGGER IF EXISTS insert_nota;

DELIMITER $$
CREATE TRIGGER insert_nota AFTER INSERT ON BD1PY2.NOTA
FOR EACH ROW
BEGIN
    SELECT NOW() INTO @fecha;
    INSERT INTO BD1PY2.HISTORIAL(fecha, descripcion, tipo) VALUES(@fecha,'Se ha insertado una nota.', 'INSERT');
END$$
DELIMITER ;

DROP TRIGGER IF EXISTS update_nota;

DELIMITER $$
CREATE TRIGGER update_nota AFTER UPDATE ON BD1PY2.NOTA
FOR EACH ROW
BEGIN
    SELECT NOW() INTO @fecha;
    INSERT INTO BD1PY2.HISTORIAL(fecha, descripcion, tipo) VALUES(@fecha,'Se ha actualizado una nota.', 'UPDATE');
END$$
DELIMITER ;

DROP TRIGGER IF EXISTS delete_nota;

DELIMITER $$
CREATE TRIGGER delete_nota AFTER DELETE ON BD1PY2.NOTA
FOR EACH ROW
BEGIN
    SELECT NOW() INTO @fecha;
    INSERT INTO BD1PY2.HISTORIAL(fecha, descripcion, tipo) VALUES(@fecha,'Se ha eliminado una nota.', 'DELETE');
END$$
DELIMITER ;

-- trigger para guardar historial de trasacciones, acta

DROP TRIGGER IF EXISTS insert_acta;

DELIMITER $$
CREATE TRIGGER insert_acta AFTER INSERT ON BD1PY2.ACTA
FOR EACH ROW
BEGIN
    SELECT NOW() INTO @fecha;
    INSERT INTO BD1PY2.HISTORIAL(fecha, descripcion, tipo) VALUES(@fecha,'Se ha insertado un acta.', 'INSERT');
END$$
DELIMITER ;

DROP TRIGGER IF EXISTS update_acta;

DELIMITER $$
CREATE TRIGGER update_acta AFTER UPDATE ON BD1PY2.ACTA
FOR EACH ROW
BEGIN
    SELECT NOW() INTO @fecha;
    INSERT INTO BD1PY2.HISTORIAL(fecha, descripcion, tipo) VALUES(@fecha,'Se ha actualizado un acta.', 'UPDATE');
END$$
DELIMITER ;

DROP TRIGGER IF EXISTS delete_acta;

DELIMITER $$
CREATE TRIGGER delete_acta AFTER DELETE ON BD1PY2.ACTA
FOR EACH ROW
BEGIN
    SELECT NOW() INTO @fecha;
    INSERT INTO BD1PY2.HISTORIAL(fecha, descripcion, tipo) VALUES(@fecha,'Se ha eliminado un acta.', 'DELETE');
END$$
DELIMITER ;



-- Funciones y Procedimientos:

-- procedimiento para lanzar mensaje de error

DROP PROCEDURE IF EXISTS msgE;

DELIMITER $$
CREATE PROCEDURE msgE(
    IN msm VARCHAR(200)
)
BEGIN
    SELECT msm as Error;
END$$
DELIMITER ;


-- procedimiento para lanzar mensaje

DROP PROCEDURE IF EXISTS msg;

DELIMITER $$
CREATE PROCEDURE msg(
    IN msm VARCHAR(200)
)
BEGIN
    SELECT msm as Response;
END$$
DELIMITER ;

-- procedimiento para crear carrera

DROP PROCEDURE IF EXISTS crearCarrera;

DELIMITER $$
CREATE PROCEDURE crearCarrera(
    IN nombre VARCHAR(30)
)
BEGIN
    -- Verifica si el nombre solo contiene letras
    IF nombre REGEXP '^[a-zA-Z ]+$' THEN
        INSERT INTO BD1PY2.CARRERA(nombre) VALUES(nombre); 
        
        call msg('Carrera creada exitosamente.');

    ELSE
        call msgE('El nombre debe contener solo letras.');
    END IF;
END$$
DELIMITER ;

-- procedimiento para registrar estudiante registrarEstudiante(202000001,'Estudiante de','Sistemas Uno','30-10-1999','sistemasuno@gmail.com',12345678,'direccion estudiantes sistemas 1',337859510101,3);

DROP PROCEDURE IF EXISTS registrarEstudiante;

DELIMITER $$
CREATE PROCEDURE registrarEstudiante(
    IN carnet VARCHAR(10),
    IN nombre VARCHAR(30),
    IN apellido VARCHAR(30),
    IN fecha_nac VARCHAR(30),
    IN correo VARCHAR(100),
    IN telefono VARCHAR(8),
    IN direccion VARCHAR(100),
    IN dpi VARCHAR(20),
    IN id_carrera VARCHAR(5)
)
proc_estudiante: BEGIN

    DECLARE fecha DATE;
    SET fecha = CURDATE();

    SET fecha_nac = STR_TO_DATE(fecha_nac, '%d-%m-%Y');

    IF carnet IS NULL THEN
        call msgE('El carnet no puede ser nulo.');
        LEAVE proc_estudiante;
    ELSEIF nombre IS NULL THEN
        call msgE('El nombre no puede ser nulo.');
        LEAVE proc_estudiante;
    ELSEIF apellido IS NULL THEN
        call msgE('El apellido no puede ser nulo.');
        LEAVE proc_estudiante;
    ELSEIF fecha_nac IS NULL THEN
        call msgE('La fecha de nacimiento no puede ser nula.');
        LEAVE proc_estudiante;
    ELSEIF correo IS NULL THEN
        call msgE('El correo no puede ser nulo.');
        LEAVE proc_estudiante;
    ELSEIF telefono IS NULL THEN
        call msgE('El telefono no puede ser nulo.');
        LEAVE proc_estudiante;
    ELSEIF direccion IS NULL THEN
        call msgE('La direccion no puede ser nula.');
        LEAVE proc_estudiante;
    ELSEIF dpi IS NULL THEN
        call msgE('El dpi no puede ser nulo.');
        LEAVE proc_estudiante;
    ELSEIF id_carrera IS NULL THEN
        call msgE('El id de carrera no puede ser nulo.');
        LEAVE proc_estudiante;
    END IF;

    IF correo REGEXP '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$' THEN

        INSERT INTO BD1PY2.ESTUDIANTE(carnet, dpi, nombre, apellido, fecha_nac, correo, telefono, direccion, creditos, fecha, id_carrera) VALUES(carnet, dpi, nombre, apellido, fecha_nac, correo, telefono, direccion, creditos, fecha, id_carrera);

        call msg('Estudiante registrado exitosamente.');

    ELSE
        call msgE('El correo no es valido.');
    END IF;
END$$

DELIMITER ;


-- procedimiento para registrar docente

DROP PROCEDURE IF EXISTS registrarDocente;

DELIMITER $$
CREATE PROCEDURE registrarDocente(
    IN nombres VARCHAR(30),
    IN apellidos VARCHAR(30),
    IN fecha_nacs VARCHAR(30),
    IN correos VARCHAR(100),
    IN telefonos VARCHAR(8),
    IN direccions VARCHAR(100),
    IN dpis VARCHAR(20),
    IN siifs VARCHAR(10)
)
proc_docente: BEGIN

    DECLARE fecha DATE;
    SET fecha = CURDATE();

    SET fecha_nacs = STR_TO_DATE(fecha_nacs, '%d-%m-%Y');

    IF siifs IS NULL THEN
        call msgE('El registro SIIF no puede ser nulo.');
        LEAVE proc_docente;
    ELSEIF nombres IS NULL THEN
        call msgE('El nombre no puede ser nulo.');
        LEAVE proc_docente;
    ELSEIF apellidos IS NULL THEN
        call msgE('El apellido no puede ser nulo.');
        LEAVE proc_docente;
    ELSEIF fecha_nacs IS NULL THEN
        call msgE('La fecha de nacimiento no puede ser nula.');
        LEAVE proc_docente;
    ELSEIF correos IS NULL THEN
        call msgE('El correo no puede ser nulo.');
        LEAVE proc_docente;
    ELSEIF telefonos IS NULL THEN
        call msgE('El telefono no puede ser nulo.');
        LEAVE proc_docente;
    ELSEIF direccions IS NULL THEN
        call msgE('La direccion no puede ser nula.');
        LEAVE proc_docente;
    ELSEIF dpis IS NULL THEN
        call msgE('El dpi no puede ser nulo.');
        LEAVE proc_docente;
    END IF;

    IF correos REGEXP '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$' THEN

        INSERT INTO BD1PY2.DOCENTE(siif, dpi, nombre, apellido, fecha_nac, correo, telefono, direccion, fecha) VALUES(siifs, dpis, nombres, apellidos, fecha_nacs, correos, telefonos, direccions, fecha);

        call msg('Docente registrado exitosamente.');

    ELSE
        call msgE('El correo no es valido.');
    END IF;
END$$
DELIMITER ;

-- procedimiento para crear curso

DROP PROCEDURE IF EXISTS crearCurso;

DELIMITER $$
CREATE PROCEDURE crearCurso(
    IN cod_cursos VARCHAR(10),
    IN nombres VARCHAR(100),
    IN creditos_necs INT,
    IN creditos_otgs INT,
    IN id_carreras INT,
    IN obligatorios BOOLEAN
)
proc_curso: BEGIN

    IF cod_cursos IS NULL THEN
        call msgE('El codigo de curso no puede ser nulo.');
        LEAVE proc_curso;
    ELSEIF nombres IS NULL THEN
        call msgE('El nombre no puede ser nulo.');
        LEAVE proc_curso;
    ELSEIF creditos_necs IS NULL THEN
        call msgE('Los creditos necesarios no pueden ser nulos.');
        LEAVE proc_curso;
    ELSEIF creditos_otgs IS NULL THEN
        call msgE('Los creditos otorgados no pueden ser nulos.');
        LEAVE proc_curso;
    ELSEIF id_carreras IS NULL THEN
        call msgE('El id de carrera no puede ser nulo.');
        LEAVE proc_curso;
    ELSEIF creditos_necs < 0 THEN
        call msgE('Los creditos necesarios deben ser un entero positivo.');
        LEAVE proc_curso;
    ELSEIF creditos_otgs < 0 THEN
        call msgE('Los creditos otorgados deben ser un entero positivo.');
        LEAVE proc_curso;
    END IF;

    INSERT INTO BD1PY2.CURSO(cod_curso, nombre, creditos_nec, creditos_otg, id_carrera, obligatorio) VALUES(cod_cursos, nombres, creditos_necs, creditos_otgs, id_carreras, obligatorios);

    call msg('Curso creado exitosamente.');

END$$
DELIMITER ;

-- procedimiento para crear curso habilitado

DROP PROCEDURE IF EXISTS habilitarCurso;

DELIMITER $$
CREATE PROCEDURE habilitarCurso(
    IN cod_cursos VARCHAR(10),
    IN ciclos VARCHAR(10),
    IN siifs VARCHAR(10),
    IN cupo_maxs INT,
    IN seccions VARCHAR(2)
)
proc_habilitarCurso: BEGIN

    DECLARE anios INT;
    SET anios = YEAR(CURDATE());

    IF cod_cursos IS NULL THEN
        CALL msgE('El código de curso no puede ser nulo.');
        LEAVE proc_habilitarCurso;
    ELSEIF ciclos IS NULL THEN
        CALL msgE('El ciclo no puede ser nulo.');
        LEAVE proc_habilitarCurso;
    ELSEIF siifs IS NULL THEN
        CALL msgE('El registro SIIF no puede ser nulo.');
        LEAVE proc_habilitarCurso;
    ELSEIF cupo_maxs IS NULL THEN
        CALL msgE('El cupo máximo no puede ser nulo.');
        LEAVE proc_habilitarCurso; 
    ELSEIF seccions IS NULL THEN
        CALL msgE('La sección no puede ser nula.');
        LEAVE proc_habilitarCurso;
    ELSEIF cupo_maxs < 0 THEN
        CALL msgE('El cupo máximo debe ser un entero positivo.');
        LEAVE proc_habilitarCurso;
    END IF;

    -- Verifica si el SIIF existe
    IF NOT EXISTS (SELECT * FROM BD1PY2.DOCENTE WHERE siif = siifs) THEN
        CALL msgE('El registro SIIF no existe.');
        LEAVE proc_habilitarCurso;
    END IF;

    -- Verifica si el código de curso existe
    IF NOT EXISTS (SELECT * FROM BD1PY2.CURSO WHERE cod_curso = cod_cursos) THEN
        CALL msgE('El código de curso no existe.');
        LEAVE proc_habilitarCurso;
    END IF;

    -- Verifica si ya existe un curso habilitado con el mismo código de curso
    IF EXISTS (SELECT * FROM BD1PY2.CURSO_HABILITADO WHERE cod_curso = cod_cursos) THEN
        CALL msgE('Ya existe un curso habilitado con el mismo código de curso.');
        LEAVE proc_habilitarCurso;
    END IF;

    -- Verifica si ya existe un curso habilitado con el mismo código de curso, ciclo y sección en el año actual
    IF EXISTS (SELECT * FROM BD1PY2.CURSO_HABILITADO WHERE cod_curso = cod_cursos AND ciclo = ciclos AND seccion = seccions AND YEAR(anio) = YEAR(CURDATE())) THEN
        CALL msgE('Ya existe un curso habilitado con el mismo código de curso, ciclo y sección en el año actual.');
        LEAVE proc_habilitarCurso;
    END IF;

    -- Si no hay conflictos, habilita el curso
    INSERT INTO BD1PY2.CURSO_HABILITADO(cod_curso, ciclo, siif, cupo_max, seccion, anio) VALUES(cod_cursos, ciclos, siifs, cupo_maxs, seccions, anios);
    INSERT INTO BD1PY2.ASIGNADOS(cantidad, id_ch) VALUES(0, LAST_INSERT_ID());
            
    CALL msg('Curso habilitado exitosamente.');

END$$
DELIMITER ;

-- procedimiento para crear horario

DROP PROCEDURE IF EXISTS agregarHorario;

DELIMITER $$
CREATE PROCEDURE agregarHorario(
    IN id_chs INT,
    IN dias INT,
    IN horas VARCHAR(20)
)
proc_agregarHorario: BEGIN

    IF id_chs IS NULL THEN
        CALL msgE('El id de curso habilitado no puede ser nulo.');
        LEAVE proc_agregarHorario;
    ELSEIF dias IS NULL THEN
        CALL msgE('El dia no puede ser nulo.');
        LEAVE proc_agregarHorario;
    ELSEIF horas IS NULL THEN
        CALL msgE('El horario no puede ser nulo.');
        LEAVE proc_agregarHorario;
    END IF;

    -- Verifica si el id de curso habilitado existe
    IF NOT EXISTS (SELECT * FROM BD1PY2.CURSO_HABILITADO WHERE id_ch = id_chs) THEN
        CALL msgE('El id de curso habilitado no existe.');
        LEAVE proc_agregarHorario;
    END IF;

    -- Verifica si el dia es valido
    IF dias < 1 OR dias > 7 THEN
        CALL msgE('El dia debe ser un entero entre 1 y 7.');
        LEAVE proc_agregarHorario;
    END IF;

    -- Verifica si el horario es valido
    IF NOT (horas REGEXP '^[0-9]{2}:[0-9]{2}-[0-9]{2}:[0-9]{2}$') THEN
        CALL msgE('El horario debe tener el formato HH:MM-HH:MM.');
        LEAVE proc_agregarHorario;
    END IF;

    -- Si no hay conflictos, agrega el horario
    INSERT INTO BD1PY2.HORARIO(dia, hora, id_ch) VALUES(dias, horas, id_chs);
            
    CALL msg('Horario agregado exitosamente.');

END$$
DELIMITER ;

-- procedimiento para asignar curso

DROP PROCEDURE IF EXISTS asignarCurso;

DELIMITER $$
CREATE PROCEDURE asignarCurso(
    IN cod_cursos VARCHAR(10),
    IN ciclos VARCHAR(10),
    IN seccions VARCHAR(2),
    IN carnets VARCHAR(10)
)
proc_asignarCurso: BEGIN
    
    IF cod_cursos IS NULL THEN
        CALL msgE('El código de curso no puede ser nulo.');
        LEAVE proc_asignarCurso;
    ELSEIF ciclos IS NULL THEN
        CALL msgE('El ciclo no puede ser nulo.');
        LEAVE proc_asignarCurso;
    ELSEIF seccions IS NULL THEN
        CALL msgE('La sección no puede ser nula.');
        LEAVE proc_asignarCurso;
    ELSEIF carnets IS NULL THEN
        CALL msgE('El carnet no puede ser nulo.');
        LEAVE proc_asignarCurso;
    END IF;

    -- Verifica si el código de curso existe a travez del id de curso habilitado
    IF NOT EXISTS (SELECT * FROM BD1PY2.CURSO_HABILITADO WHERE cod_curso = cod_cursos) THEN
        CALL msgE('El curso no se encuentra habilitado.');
        LEAVE proc_asignarCurso;
    END IF;

    -- Verifica si el carnet existe
    IF NOT EXISTS (SELECT * FROM BD1PY2.ESTUDIANTE WHERE carnet = carnets) THEN
        CALL msgE('El carnet no existe.');
        LEAVE proc_asignarCurso;
    END IF;

    -- verifica si el estudiante cumple con los creditos necesarios
    IF (SELECT creditos FROM BD1PY2.ESTUDIANTE WHERE carnet = carnets) < (SELECT creditos_nec FROM BD1PY2.CURSO WHERE cod_curso = cod_cursos) THEN
        CALL msgE('El estudiante no cumple con los creditos necesarios.');
        LEAVE proc_asignarCurso;
    END IF;

    IF EXISTS (SELECT * FROM BD1PY2.ASIGNACION WHERE carnet = carnets AND id_ch = (SELECT id_ch FROM BD1PY2.CURSO_HABILITADO WHERE cod_curso = cod_cursos AND ciclo = ciclos AND seccion = seccions AND anio = YEAR(CURDATE()))) THEN
        CALL msgE('El estudiante ya esta asignado al curso.');
        LEAVE proc_asignarCurso;
    END IF;

    -- verifica si el estudiante pertenece a la carrera del curso excepto si es area comun
    IF (SELECT id_carrera FROM BD1PY2.ESTUDIANTE WHERE carnet = carnets) != (SELECT id_carrera FROM BD1PY2.CURSO WHERE cod_curso = cod_cursos) AND (SELECT id_carrera FROM BD1PY2.CURSO WHERE cod_curso = cod_cursos) != 0 THEN
        CALL msgE('El estudiante no pertenece a la carrera del curso.');
        LEAVE proc_asignarCurso;
    END IF;
    
    
    -- Verifica si el curso tiene cupos disponibles
    IF (SELECT cantidad FROM BD1PY2.ASIGNADOS WHERE id_ch = (SELECT id_ch FROM BD1PY2.CURSO_HABILITADO WHERE cod_curso = cod_cursos AND ciclo = ciclos AND seccion = seccions AND anio = YEAR(CURDATE()))) >= (SELECT cupo_max FROM BD1PY2.CURSO_HABILITADO WHERE cod_curso = cod_cursos AND ciclo = ciclos AND seccion = seccions AND anio = YEAR(CURDATE())) THEN
        CALL msgE('El curso no tiene cupos disponibles.');
        LEAVE proc_asignarCurso;
    END IF;

    -- verifica si la seccion existe
    IF NOT EXISTS (SELECT * FROM BD1PY2.HORARIO WHERE id_ch = (SELECT id_ch FROM BD1PY2.CURSO_HABILITADO WHERE cod_curso = cod_cursos AND ciclo = ciclos AND seccion = seccions AND anio = YEAR(CURDATE()))) THEN
        CALL msgE('La seccion no existe.');
        LEAVE proc_asignarCurso;
    END IF;

    -- Si no hay conflictos, asigna el curso
    INSERT INTO BD1PY2.ASIGNACION(carnet, id_ch) VALUES(carnets, (SELECT id_ch FROM BD1PY2.CURSO_HABILITADO WHERE cod_curso = cod_cursos AND ciclo = ciclos AND seccion = seccions AND anio = YEAR(CURDATE())));
    UPDATE BD1PY2.ASIGNADOS SET cantidad = cantidad + 1 WHERE id_ch = (SELECT id_ch FROM BD1PY2.CURSO_HABILITADO WHERE cod_curso = cod_cursos AND ciclo = ciclos AND seccion = seccions AND anio = YEAR(CURDATE()));

    CALL msg('Curso asignado exitosamente.');


END$$
DELIMITER ;

-- procedimiento para desasignar curso

DROP PROCEDURE IF EXISTS desasignarCurso;

DELIMITER $$
CREATE PROCEDURE desasignarCurso(
    IN cod_cursos VARCHAR(10),
    IN ciclos VARCHAR(10),
    IN seccions VARCHAR(2),
    IN carnets VARCHAR(10)
)
proc_desasignarCurso: BEGIN
    
    IF cod_cursos IS NULL THEN
        CALL msgE('El código de curso no puede ser nulo.');
        LEAVE proc_desasignarCurso;
    ELSEIF ciclos IS NULL THEN
        CALL msgE('El ciclo no puede ser nulo.');
        LEAVE proc_desasignarCurso;
    ELSEIF seccions IS NULL THEN
        CALL msgE('La sección no puede ser nula.');
        LEAVE proc_desasignarCurso;
    ELSEIF carnets IS NULL THEN
        CALL msgE('El carnet no puede ser nulo.');
        LEAVE proc_desasignarCurso;
    END IF;

    -- Verifica si el carnet existe
    IF NOT EXISTS (SELECT * FROM BD1PY2.ESTUDIANTE WHERE carnet = carnets) THEN
        CALL msgE('El carnet no existe.');
        LEAVE proc_desasignarCurso;
    END IF;

    -- Verifica si el estudiante esta asignado al curso
    IF NOT EXISTS (SELECT * FROM BD1PY2.ASIGNACION WHERE carnet = carnets AND id_ch = (SELECT id_ch FROM BD1PY2.CURSO_HABILITADO WHERE cod_curso = cod_cursos AND ciclo = ciclos AND seccion = seccions AND anio = YEAR(CURDATE()))) THEN
        CALL msgE('El estudiante no esta asignado al curso.');
        LEAVE proc_desasignarCurso;
    END IF;

    -- verifica si el estudiante pertenece a la carrera del curso excepto si es area comun
    IF (SELECT id_carrera FROM BD1PY2.ESTUDIANTE WHERE carnet = carnets) != (SELECT id_carrera FROM BD1PY2.CURSO WHERE cod_curso = cod_cursos) AND (SELECT id_carrera FROM BD1PY2.CURSO WHERE cod_curso = cod_cursos) != 0 THEN
        CALL msgE('El estudiante no pertenece a la carrera del curso.');
        LEAVE proc_desasignarCurso;
    END IF;

    -- Si no hay conflictos, desasigna el curso
    DELETE FROM BD1PY2.ASIGNACION WHERE carnet = carnets AND id_ch = (SELECT id_ch FROM BD1PY2.CURSO_HABILITADO WHERE cod_curso = cod_cursos AND ciclo = ciclos AND seccion = seccions AND anio = YEAR(CURDATE()));
    UPDATE BD1PY2.ASIGNADOS SET cantidad = cantidad - 1 WHERE id_ch = (SELECT id_ch FROM BD1PY2.CURSO_HABILITADO WHERE cod_curso = cod_cursos AND ciclo = ciclos AND seccion = seccions AND anio = YEAR(CURDATE()));
    INSERT INTO BD1PY2.DESASIGNACION(carnet, id_ch) VALUES(carnets, (SELECT id_ch FROM BD1PY2.CURSO_HABILITADO WHERE cod_curso = cod_cursos AND ciclo = ciclos AND seccion = seccions AND anio = YEAR(CURDATE())));

    CALL msg('Curso desasignado exitosamente.');

END$$
DELIMITER ;


-- procedimiento para ingresar notas

DROP PROCEDURE IF EXISTS ingresarNota;

DELIMITER $$
CREATE PROCEDURE ingresarNota(
    IN cod_cursos VARCHAR(10),
    IN ciclos VARCHAR(10),
    IN seccions VARCHAR(2),
    IN carnets VARCHAR(10),
    IN notas INT
)
proc_ingresarNota: BEGIN
    
    IF cod_cursos IS NULL THEN
        CALL msgE('El código de curso no puede ser nulo.');
        LEAVE proc_ingresarNota;
    ELSEIF ciclos IS NULL THEN
        CALL msgE('El ciclo no puede ser nulo.');
        LEAVE proc_ingresarNota;
    ELSEIF seccions IS NULL THEN
        CALL msgE('La sección no puede ser nula.');
        LEAVE proc_ingresarNota;
    ELSEIF carnets IS NULL THEN
        CALL msgE('El carnet no puede ser nulo.');
        LEAVE proc_ingresarNota;
    ELSEIF notas IS NULL THEN
        CALL msgE('La nota no puede ser nula.');
        LEAVE proc_ingresarNota;
    ELSEIF notas < 0 THEN
        CALL msgE('La nota debe ser un entero positivo.');
        LEAVE proc_ingresarNota;
    END IF;

    -- Verifica si el carnet existe
    IF NOT EXISTS (SELECT * FROM BD1PY2.ESTUDIANTE WHERE carnet = carnets) THEN
        CALL msgE('El carnet no existe.');
        LEAVE proc_ingresarNota;
    END IF;

    -- Verifica si el estudiante esta asignado al curso
    IF NOT EXISTS (SELECT * FROM BD1PY2.ASIGNACION WHERE carnet = carnets AND id_ch = (SELECT id_ch FROM BD1PY2.CURSO_HABILITADO WHERE cod_curso = cod_cursos AND ciclo = ciclos AND seccion = seccions AND anio = YEAR(CURDATE()))) THEN
        CALL msgE('El estudiante no esta asignado al curso.');
        LEAVE proc_ingresarNota;
    END IF;

    -- verifica si el estudiante pertenece a la carrera del curso excepto si es area comun
    IF (SELECT id_carrera FROM BD1PY2.ESTUDIANTE WHERE carnet = carnets) != (SELECT id_carrera FROM BD1PY2.CURSO WHERE cod_curso = cod_cursos) AND (SELECT id_carrera FROM BD1PY2.CURSO WHERE cod_curso = cod_cursos) != 0 THEN
        CALL msgE('El estudiante no pertenece a la carrera del curso.');
        LEAVE proc_ingresarNota;
    END IF;

    -- si la nota viene en decimales redondearla al entero mas cercano
    SET notas = ROUND(notas);

    -- verifica si el estudiante ya tiene una nota ingresada
    IF EXISTS (SELECT * FROM BD1PY2.NOTA WHERE carnet = carnets AND id_ch = (SELECT id_ch FROM BD1PY2.CURSO_HABILITADO WHERE cod_curso = cod_cursos AND ciclo = ciclos AND seccion = seccions AND anio = YEAR(CURDATE())) AND nota IS NOT NULL) THEN
        UPDATE BD1PY2.NOTA SET nota = notas WHERE carnet = carnets AND id_ch = (SELECT id_ch FROM BD1PY2.CURSO_HABILITADO WHERE cod_curso = cod_cursos AND ciclo = ciclos AND seccion = seccions AND anio = YEAR(CURDATE()));
        IF notas >= 61 THEN
            UPDATE BD1PY2.ESTUDIANTE SET creditos = creditos + (SELECT creditos_otg FROM BD1PY2.CURSO WHERE cod_curso = cod_cursos) WHERE carnet = carnets;
        END IF;
        CALL msgE('Se ha actualizado la nota del estudiante.');
        LEAVE proc_ingresarNota;
    END IF;

    -- Si no hay conflictos, ingresa la nota
    INSERT INTO BD1PY2.NOTA(carnet, id_ch, nota) VALUES(carnets, (SELECT id_ch FROM BD1PY2.CURSO_HABILITADO WHERE cod_curso = cod_cursos AND ciclo = ciclos AND seccion = seccions AND anio = YEAR(CURDATE())), notas);
    
    -- si la nota es mayor o igual a 61, el estudiante aprobo y se agregan los creditos otorgados al estudiante
    IF notas >= 61 THEN
        UPDATE BD1PY2.ESTUDIANTE SET creditos = creditos + (SELECT creditos_otg FROM BD1PY2.CURSO WHERE cod_curso = cod_cursos) WHERE carnet = carnets;
    END IF;

    CALL msg('Nota ingresada exitosamente.');

END$$
DELIMITER ;

-- procedimiento para generar acta

DROP PROCEDURE IF EXISTS generarActa;

DELIMITER $$
CREATE PROCEDURE generarActa(
    IN cod_cursos VARCHAR(10),
    IN ciclos VARCHAR(10),
    IN seccions VARCHAR(2)
)
proc_generarActa: BEGIN

    DECLARE fechas DATE;
    DECLARE horas TIME;
    SET horas = CURTIME();
    SET fechas = CURDATE();

    IF cod_cursos IS NULL THEN
        CALL msgE('El código de curso no puede ser nulo.');
        LEAVE proc_generarActa;
    ELSEIF ciclos IS NULL THEN
        CALL msgE('El ciclo no puede ser nulo.');
        LEAVE proc_generarActa;
    ELSEIF seccions IS NULL THEN
        CALL msgE('La sección no puede ser nula.');
        LEAVE proc_generarActa;
    END IF;

    -- Verifica si el curso esta habilitado
    IF NOT EXISTS (SELECT * FROM BD1PY2.CURSO_HABILITADO WHERE cod_curso = cod_cursos AND ciclo = ciclos AND seccion = seccions AND anio = YEAR(CURDATE())) THEN
        CALL msgE('El curso no esta habilitado.');
        LEAVE proc_generarActa;
    END IF;

    -- Verifica si el curso tiene asignaciones
    IF NOT EXISTS (SELECT * FROM BD1PY2.ASIGNACION WHERE id_ch = (SELECT id_ch FROM BD1PY2.CURSO_HABILITADO WHERE cod_curso = cod_cursos AND ciclo = ciclos AND seccion = seccions)) THEN
        CALL msgE('El curso no tiene asignaciones.');
        LEAVE proc_generarActa;
    END IF;

    -- Verifica si el curso tiene notas ingresadas
    IF NOT EXISTS (SELECT * FROM BD1PY2.NOTA WHERE id_ch = (SELECT id_ch FROM BD1PY2.CURSO_HABILITADO WHERE cod_curso = cod_cursos AND ciclo = ciclos AND seccion = seccions)) THEN
        CALL msgE('El curso no tiene notas ingresadas.');
        LEAVE proc_generarActa;
    END IF;

    -- Ingresar en tabla acta
    INSERT INTO BD1PY2.ACTA(fecha, hora, id_ch) VALUES(fechas, horas, (SELECT id_ch FROM BD1PY2.CURSO_HABILITADO WHERE cod_curso = cod_cursos AND ciclo = ciclos AND seccion = seccions));

    -- Si no hay conflictos, genera el acta
    SELECT carnet, nombre, apellido, nota FROM BD1PY2.NOTA NATURAL JOIN BD1PY2.ESTUDIANTE WHERE id_ch = (SELECT id_ch FROM BD1PY2.CURSO_HABILITADO WHERE cod_curso = cod_cursos AND ciclo = ciclos AND seccion = seccions);

END$$
DELIMITER ;




-- Procesamiento de datos:

-- procedimiento para consultar pensum

DROP PROCEDURE IF EXISTS consultarPensum;

DELIMITER $$
CREATE PROCEDURE consultarPensum(
    IN id_carreras INT
)
proc_consultarPensum: BEGIN

    IF id_carreras IS NULL THEN
        CALL msgE('El id de carrera no puede ser nulo.');
        LEAVE proc_consultarPensum;
    END IF;

    -- Verifica si el id de carrera existe
    IF NOT EXISTS (SELECT * FROM BD1PY2.CARRERA WHERE id_carrera = id_carreras) THEN
        CALL msgE('El id de carrera no existe.');
        LEAVE proc_consultarPensum;
    END IF;

    -- Si no hay conflictos, consulta el pensum
    SELECT cod_curso, nombre, creditos_nec, creditos_otg, obligatorio FROM BD1PY2.CURSO WHERE id_carrera = id_carreras;

END$$
DELIMITER ;


-- procedimiento para consultar estudiante

DROP PROCEDURE IF EXISTS consultarEstudiante;

DELIMITER $$
CREATE PROCEDURE consultarEstudiante(
    IN carnets VARCHAR(10)
)
proc_consultarEstudiante: BEGIN

    IF carnets IS NULL THEN
        CALL msgE('El carnet no puede ser nulo.');
        LEAVE proc_consultarEstudiante;
    END IF;

    -- Verifica si el carnet existe
    IF NOT EXISTS (SELECT * FROM BD1PY2.ESTUDIANTE WHERE carnet = carnets) THEN
        CALL msgE('El carnet no existe.');
        LEAVE proc_consultarEstudiante;
    END IF;

    -- Si no hay conflictos, consulta el estudiante
    SELECT carnet as Carnet, CONCAT(nombre,' ', apellido) as 'Nombre Completo', DATE_FORMAT(fecha_nac, '%d-%m-%Y') as 'Fecha de Nacimiento', correo as Correo, telefono as Telefono, direccion as Direccion, dpi as 'Numero de DPI', (SELECT nombre FROM BD1PY2.CARRERA WHERE id_carrera = (SELECT id_carrera FROM BD1PY2.ESTUDIANTE WHERE carnet = carnets)) as 'Carrera',creditos as 'Creditos' FROM BD1PY2.ESTUDIANTE WHERE carnet = carnets;

END$$
DELIMITER ;

-- procedimiento para consultar docente

DROP PROCEDURE IF EXISTS consultarDocente;

DELIMITER $$
CREATE PROCEDURE consultarDocente(
    IN siifs VARCHAR(10)
)
proc_consultarDocente: BEGIN

    IF siifs IS NULL THEN
        CALL msgE('El registro SIIF no puede ser nulo.');
        LEAVE proc_consultarDocente;
    END IF;

    -- Verifica si el registro SIIF existe
    IF NOT EXISTS (SELECT * FROM BD1PY2.DOCENTE WHERE siif = siifs) THEN
        CALL msgE('El registro SIIF no existe.');
        LEAVE proc_consultarDocente;
    END IF;

    -- Si no hay conflictos, consulta el docente
    SELECT siif as 'Registro SIIF', CONCAT(nombre,' ', apellido) as 'Nombre Completo', DATE_FORMAT(fecha_nac, '%d-%m-%Y') as 'Fecha de Nacimiento', correo as Correo, telefono as Telefono, direccion as Direccion, dpi as 'Numero de DPI' FROM BD1PY2.DOCENTE WHERE siif = siifs;

END$$
DELIMITER ;


-- procedimiento para consultar asignados

DROP PROCEDURE IF EXISTS consultarAsignados;

DELIMITER $$
CREATE PROCEDURE consultarAsignados(
    IN cod_cursos VARCHAR(10),
    IN ciclos VARCHAR(10),
    IN anio INT,
    IN seccions VARCHAR(2)
)
proc_consultarAsignados: BEGIN

    IF cod_cursos IS NULL THEN
        CALL msgE('El código de curso no puede ser nulo.');
        LEAVE proc_consultarAsignados;
    ELSEIF ciclos IS NULL THEN
        CALL msgE('El ciclo no puede ser nulo.');
        LEAVE proc_consultarAsignados;
    ELSEIF anio IS NULL THEN
        CALL msgE('El año no puede ser nulo.');
        LEAVE proc_consultarAsignados;
    ELSEIF seccions IS NULL THEN
        CALL msgE('La sección no puede ser nula.');
        LEAVE proc_consultarAsignados;
    END IF;

    -- Verifica si el curso esta habilitado
    IF NOT EXISTS (SELECT * FROM BD1PY2.CURSO_HABILITADO WHERE cod_curso = cod_cursos AND ciclo = ciclos AND anio = anio AND seccion = seccions) THEN
        CALL msgE('El curso no esta habilitado.');
        LEAVE proc_consultarAsignados;
    END IF;

    -- Si no hay conflictos, consulta los asignados
    SELECT carnet as Carnet, CONCAT(nombre,' ', apellido) as 'Nombre Completo', creditos as 'Creditos' FROM BD1PY2.ESTUDIANTE NATURAL JOIN BD1PY2.ASIGNACION WHERE id_ch = (SELECT id_ch FROM BD1PY2.CURSO_HABILITADO WHERE cod_curso = cod_cursos AND ciclo = ciclos AND anio = anio AND seccion = seccions);

END$$
DELIMITER ;



-- procedimiento para consultar aprobacion

DROP PROCEDURE IF EXISTS consultarAprobacion;

DELIMITER $$
CREATE PROCEDURE consultarAprobacion(
    IN cod_cursos VARCHAR(10),
    IN ciclos VARCHAR(10),
    IN anio INT,
    IN seccions VARCHAR(2)
)
proc_consultarAprobacion: BEGIN

    IF cod_cursos IS NULL THEN
        CALL msgE('El código de curso no puede ser nulo.');
        LEAVE proc_consultarAprobacion;
    ELSEIF ciclos IS NULL THEN
        CALL msgE('El ciclo no puede ser nulo.');
        LEAVE proc_consultarAprobacion;
    ELSEIF anio IS NULL THEN
        CALL msgE('El año no puede ser nulo.');
        LEAVE proc_consultarAprobacion;
    ELSEIF seccions IS NULL THEN
        CALL msgE('La sección no puede ser nula.');
        LEAVE proc_consultarAprobacion;
    END IF;

    -- Verifica si el curso esta habilitado
    IF NOT EXISTS (SELECT * FROM BD1PY2.CURSO_HABILITADO WHERE cod_curso = cod_cursos AND ciclo = ciclos AND anio = anio AND seccion = seccions) THEN
        CALL msgE('El curso no esta habilitado.');
        LEAVE proc_consultarAprobacion;
    END IF;

    -- Si no hay conflictos, consulta la aprobacion
    SELECT cod_cursos as 'Codigo de Curso', carnet as Carnet, CONCAT(nombre,' ', apellido) as 'Nombre Completo', IF(nota >= 61, 'APROBADO', 'DESAPROBADO') as 'Estado' FROM BD1PY2.NOTA NATURAL JOIN BD1PY2.ESTUDIANTE WHERE id_ch = (SELECT id_ch FROM BD1PY2.CURSO_HABILITADO WHERE cod_curso = cod_cursos AND ciclo = ciclos AND anio = anio AND seccion = seccions);

END$$
DELIMITER ;

-- procedimiento para consultar actas

DROP PROCEDURE IF EXISTS consultarActas;

DELIMITER $$
CREATE PROCEDURE consultarActas(
    IN cod_cursos VARCHAR(10)
)
proc_consultarActas: BEGIN

    IF cod_cursos IS NULL THEN
        CALL msgE('El código de curso no puede ser nulo.');
        LEAVE proc_consultarActas;
    END IF;

    -- Verifica si el curso esta habilitado
    IF NOT EXISTS (SELECT * FROM BD1PY2.CURSO_HABILITADO WHERE cod_curso = cod_cursos) THEN
        CALL msgE('El curso no esta habilitado.');
        LEAVE proc_consultarActas;
    END IF;

    -- Si no hay conflictos, consulta las actas
    SELECT cod_curso as 'Codigo de Curso', seccion as Seccion, IF(ciclo = '1S', 'PRIMER SEMESTRE', IF(ciclo = '2S', 'SEGUNDO SEMESTRE', IF(ciclo = 'VJ', 'VACACIONES DE JUNIO', IF(ciclo = 'VD', 'VACACIONES DE DICIEMBRE', 'DESCONOCIDO')))) as Ciclo, anio as Anio, (SELECT COUNT(*) FROM BD1PY2.NOTA WHERE id_ch = (SELECT id_ch FROM BD1PY2.CURSO_HABILITADO WHERE cod_curso = cod_cursos AND ciclo = ciclo AND anio = anio AND seccion = seccion)) as 'Cantidad de Estudiantes', CONCAT(fecha, ' ', hora) as 'Fecha y Hora de Generado' FROM BD1PY2.ACTA NATURAL JOIN BD1PY2.CURSO_HABILITADO WHERE cod_curso = cod_cursos;

END$$
DELIMITER ;

-- procedimiento para consultar tasa de desasignacion

DROP PROCEDURE IF EXISTS consultarDesasignacion;

DELIMITER $$
CREATE PROCEDURE consultarDesasignacion(
    IN cod_cursos VARCHAR(10),
    IN ciclos VARCHAR(10),
    IN anio INT,
    IN seccions VARCHAR(2)
)

proc_consultarDesasignacion: BEGIN

    IF cod_cursos IS NULL THEN
        CALL msgE('El código de curso no puede ser nulo.');
        LEAVE proc_consultarDesasignacion;
    ELSEIF ciclos IS NULL THEN
        CALL msgE('El ciclo no puede ser nulo.');
        LEAVE proc_consultarDesasignacion;
    ELSEIF anio IS NULL THEN
        CALL msgE('El año no puede ser nulo.');
        LEAVE proc_consultarDesasignacion;
    ELSEIF seccions IS NULL THEN
        CALL msgE('La sección no puede ser nula.');
        LEAVE proc_consultarDesasignacion;
    END IF;

    -- Verifica si el curso esta habilitado
    IF NOT EXISTS (SELECT * FROM BD1PY2.CURSO_HABILITADO WHERE cod_curso = cod_cursos AND ciclo = ciclos AND anio = anio AND seccion = seccions) THEN
        CALL msgE('El curso no esta habilitado.');
        LEAVE proc_consultarDesasignacion;
    END IF;

    -- Si no hay conflictos, consulta la desasignacion
    SELECT cod_curso as 'Codigo de Curso', seccion as Seccion, IF(ciclo = '1S', 'PRIMER SEMESTRE', IF(ciclo = '2S', 'SEGUNDO SEMESTRE', IF(ciclo = 'VJ', 'VACACIONES DE JUNIO', IF(ciclo = 'VD', 'VACACIONES DE DICIEMBRE', 'DESCONOCIDO')))) as Ciclo, anio as Anio, (SELECT COUNT(*) FROM BD1PY2.ASIGNACION WHERE id_ch = (SELECT id_ch FROM BD1PY2.CURSO_HABILITADO WHERE cod_curso = cod_cursos AND ciclo = ciclo AND anio = anio AND seccion = seccion)) as 'Cantidad de Estudiantes', (SELECT COUNT(*) FROM BD1PY2.DESASIGNACION WHERE id_ch = (SELECT id_ch FROM BD1PY2.CURSO_HABILITADO WHERE cod_curso = cod_cursos AND ciclo = ciclo AND anio = anio AND seccion = seccion)) as 'Cantidad de Desasignados', CONCAT(ROUND((SELECT COUNT(*) FROM BD1PY2.DESASIGNACION WHERE id_ch = (SELECT id_ch FROM BD1PY2.CURSO_HABILITADO WHERE cod_curso = cod_cursos AND ciclo = ciclo AND anio = anio AND seccion = seccion)) / (SELECT COUNT(*) FROM BD1PY2.ASIGNACION WHERE id_ch = (SELECT id_ch FROM BD1PY2.CURSO_HABILITADO WHERE cod_curso = cod_cursos AND ciclo = ciclo AND anio = anio AND seccion = seccion)) * 100), '%') as 'Porcentaje de Desasignacion' FROM BD1PY2.CURSO_HABILITADO WHERE cod_curso = cod_cursos AND ciclo = ciclos AND anio = anio AND seccion = seccions;

END$$
DELIMITER ;



